<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F3D AR Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10;
        }
        /* Style for the loading message or UI */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 20;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>请将摄像头对准 Hiro 或 Kanji 标识物</div>
        <div style="margin: 5px 0;">
            <a href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.png" target="_blank" style="color: lightblue; margin-right: 10px;">打开 Hiro 图片</a>
            <a href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/kanji.png" target="_blank" style="color: lightblue;">打开 Kanji 图片</a>
        </div>
        <label><input type="checkbox" id="persistToggle"> 丢失标识物后保持模型 (Scan Once Mode)</label>
    </div>
    <div id="container"></div>

    <!-- Import F3D and setup AR -->
    <script type="module">
        import * as F3D from './f3d.es.js';

        // 1. Expose F3D exports as global THREE object for AR.js
        window.THREE = { ...F3D };
        if (!window.THREE.Math) {
            window.THREE.Math = window.THREE.MathUtils;
        }
        
        // 2. Load AR.js dynamically
        const script = document.createElement('script');
        script.src = 'https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex.js';
        script.onload = initAR;
        document.body.appendChild(script);

        async function initAR() {
            console.log('AR.js loaded');

            // Load Configuration from "Database" (JSON file)
            let arData = [];
            try {
                const response = await fetch('./models.json');
                arData = await response.json();
            } catch (e) {
                console.error("Failed to load models.json", e);
                // Fallback data
                arData = [{
                    markerUrl: 'https://raw.githack.com/AR-js-org/AR.js/master/data/data/patt.hiro',
                    type: 'box',
                    color: 'green'
                }];
            }

            // 3. Initialize F3D App
            const app = new F3D.F3dApp({
                container: document.getElementById('container'),
                autoStart: false, 
                transparentBackground: true,
                camera: { 
                    position: { x: 0, y: 0, z: 0 },
                    limits: { distance: { min: 0, max: 1000 } } 
                }
            });

            const engine = app.engine;
            const scene = app.scene;
            const camera = app.camera;
            const renderer = engine.renderer;

            // 4. Initialize AR.js Source
            const arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
            });

            arToolkitSource.init(function onReady(){
                onResize();
            });

            window.addEventListener('resize', function(){
                onResize();
            });

            function onResize(){
                arToolkitSource.onResizeElement();
                arToolkitSource.copyElementSizeTo(renderer.domElement);
                if(arToolkitContext.arController !== null){
                    arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
                }
            }

            // 5. Initialize AR.js Context
            const arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'https://raw.githack.com/AR-js-org/AR.js/master/data/data/camera_para.dat',
                detectionMode: 'mono',
                // 回调参数以提高稳定性，降低误识别率
                maxDetectionRate: 30, 
                canvasWidth: 80 * 3,
                canvasHeight: 60 * 3,
            });

            arToolkitContext.init(function onCompleted(){
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            });

            // 6. Create Markers dynamically from Data
            const markerControlsList = [];
            const persistCheckbox = document.getElementById('persistToggle');

            arData.forEach(item => {
                const markerRoot = new F3D.Group();
                markerRoot.name = `markerRoot_${item.id}`;
                markerRoot.visible = false; 
                scene.add(markerRoot);

                // Create AR Marker Control
                const controls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                    type: 'pattern',
                    patternUrl: item.markerUrl,
                    smooth: true,
                    smoothCount: 10,       // 增加平滑缓冲
                    smoothTolerance: 0.01,
                    smoothThreshold: 2
                });
                
                // Custom state for stability
                controls.foundCounter = 0;
                controls.lostCounter = 0;
                controls.isStableFound = false; // 稳定的识别状态

                markerControlsList.push({
                    controls: controls,
                    root: markerRoot
                });

                // Add Model based on type
                let mesh;
                if (item.type === 'box') {
                    const geometry = new F3D.BoxGeometry(1, 1, 1);
                    const material = new F3D.MeshNormalMaterial({ transparent: true, opacity: 0.8 });
                    if (item.color) material.color = new F3D.Color(item.color);
                    mesh = new F3D.Mesh(geometry, material);
                } else if (item.type === 'sphere') {
                    const geometry = new F3D.SphereGeometry(0.5, 32, 32);
                    const material = new F3D.MeshNormalMaterial({ wireframe: true });
                    mesh = new F3D.Mesh(geometry, material);
                }
                
                if (mesh) {
                    mesh.position.y = 0.5;
                    if (item.scale) mesh.scale.set(item.scale[0], item.scale[1], item.scale[2]);
                    markerRoot.add(mesh);
                    
                    engine.addUpdateCallback(`anim_${item.id}`, (dt) => {
                        // 只有在显示的时候才旋转，节省性能
                        if (markerRoot.visible) {
                            mesh.rotation.y += dt;
                            mesh.rotation.x += dt * 0.5;
                        }
                    });
                }
            });

            // 9. Update Loop with Anti-Flicker & Persistence Logic
            const STABLE_THRESHOLD = 5; // 连续识别 N 帧才显示
            const LOST_THRESHOLD = 10;  // 连续丢失 N 帧才隐藏

            engine.addUpdateCallback('ar_update', (deltaTime) => {
                if(arToolkitSource.ready !== false){
                    arToolkitContext.update(arToolkitSource.domElement);
                }
                
                // Handle Visibility Logic
                markerControlsList.forEach(item => {
                    const { controls, root } = item;
                    
                    // AR.js 当前帧的检测结果
                    const isRawVisible = root.visible;
                    
                    if (isRawVisible) {
                        controls.foundCounter++;
                        controls.lostCounter = 0;
                    } else {
                        controls.lostCounter++;
                        controls.foundCounter = 0;
                    }

                    // 状态机转换
                    if (controls.foundCounter >= STABLE_THRESHOLD) {
                        controls.isStableFound = true;
                    } else if (controls.lostCounter >= LOST_THRESHOLD) {
                        controls.isStableFound = false;
                    }

                    // 最终可见性决策
                    if (persistCheckbox.checked) {
                        // 如果开启了保持模式：
                        // 只要曾经稳定识别过 (isStableFound 曾经为 true，或者当前为 true)
                        // 这里简化逻辑：如果当前是稳定状态，显示；
                        // 如果当前不是稳定状态（即丢失了），但之前找到过，也显示。
                        // 实际上，只要 persist 开启，我们就不让它变回 false，除非用户重置。
                        
                        // 我们需要一个标记来记录是否“曾经”稳定识别过，这个在 controls 对象上没有，我们加一个
                        if (controls.isStableFound) {
                            controls.hasEverBeenStable = true;
                        }

                        if (controls.hasEverBeenStable) {
                             root.visible = true;
                        } else {
                             root.visible = controls.isStableFound;
                        }
                        
                    } else {
                        // 默认模式：只在稳定识别时显示
                        root.visible = controls.isStableFound;
                    }
                });
            });

            app.start();

            if (engine.editController) {
                engine.editController.enabled = false; 
            }
        }
    </script>
</body>
</html>